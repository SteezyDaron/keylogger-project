CHAPTER ONE.

1.0 -INTRODUCTION
Keyloggers are a type of malware that nefariously monitors client input from the console
in an effort to extract personal and sensitive information. Keyloggers can email or ftp the
document containing the keystrokes they have recorded back to the spy. These keyloggers
operate covertly and out of sight to record client activity on the console, and each
keystroke is recorded in a document that is well-obscured.
The console is the primary target for Keyloggers to recover client input from because it is
the most widely used UI on a PC. Although there are both software and hardware
keyloggers, programming keyloggers provide the most risk if users have anything valuable
on their PC.
The use of equipment keyloggers indicates a real risk to PC users' privacy. For instance,
practical keylogging devices, such as the Spy Keylogger, act as a conduit between various
PC components, such as physical consoles, USB connectors, motherboards, and USB
Ports; they perform a "man in the middle attack".
All keystrokes made by users are covertly recorded and stored on this type of device's
memory.
The base component of Trojan stallions that is introduced by increased physical access to
the computer or by programs that are carelessly downloaded is the software-based
keylogger.
They leave little trace in terms of memory and CPU consumption, making them almost
untraceable.
Programming Keyloggers are programs that record keystrokes made on a client's computer
and then relay the information to a spy. Given the availability of many internet free
applications, installing Keyloggers on a victim's computer without their knowledge is not
difficult.
1.1 -OBJECTIVE
The main objective of keyloggers is to interfere in the chain of events that
happen when a key is pressed and when the data is displayed on the

monitor as a result of a keystroke and there fore the Detection system
detects the keylogger and notifies you.
The detector compares the signatures of the files that are scanned with those
in the database.
1.2- PURPOSE
Identity theft, which is typically carried out through keylogger programs that aim to
collect private information or login credentials by covertly capturing user inputs, is
one of the greatest risks to cyber security in today's age of the internet. Personal
activities are some of the most susceptible to keylogger attacks, including online
shopping, online banking, email, and chat.
Keyloggers are not as well-known as viruses and worms. Keyloggers often receive a
paragraph of attention in the standard reference on viruses, worms, and Trojan
Horses. One defense against these attacks is a signature-based keylogger detector,
which can search all user files with the necessary permissions.
On the basis of in-depth analysis of both old and recent keyloggers, a signature
database was developed. The detector compares the signatures of the files that are
scanned with those in the database.

1.4 -PROBLEM IDENTIFICATION.
Keyloggers have existed for a very long time, but due to the Internet's ongoing
development, they are currently the most significant threat a business faces.
Keyloggers served as the foundation for Trojan Horses, which in turn gave rise to
the new malware family known as ransomware. Because attackers increasingly
demand ransom in order to protect users' systems and files, this puts cyber security
at risk. 2017 saw numerous instances of this assault, including Petya, EternalBlue,
and WannaCry. Extortion tactics are frequently used in these attacks.
Keyloggers are primarily built specifically for a single functionality of logging, as
opposed to viruses and worms, which frequently propagate across one system or
other systems. They do not harm the systems by infecting them like viruses do.
Instead, keylogging software tracks the victim's keystrokes in order to stealthily
record sensitive information from online activity.
Keyloggers record the keystrokes that are made and store this data in hidden log
files, which is then sent to the attacker. Keyloggers eventually leave behind a
minimal memory and CPU usage footprint as a result of their actions. The majority
of them are neither visible in the "Task Manager" nor discernible among processes.
Even after listing the entire directory, it can be difficult to discern between the log
files and the OS files.

1.5 -ADVANTAGES OF A KEY-LOGGER DETECTION SYSTEM.
-A Keylogger Detector Prevents a Data Breach
 With the sensitive information in the wrong hand, hackers can use it to extort
money from victims. A keylogger detector protects data stored on endpoint devices.
It detects a keylogger distributed by spear phishing, drive-by-downloads, and
phishing URLs.
-Less Risk of Data Theft.
 Companies can also be more proactive about protecting themselves from a huge
threat in today’s world, data theft.

1.6-DISADVANTAGES OF A KEY-LOGGER DETECTION SYSTEM.
-Lack of proper education.
 Many who are not informed about the Keylogger detection system will not agree to
put it on their machines due to misinformation.

CHAPTER TWO

2.1 KEYLOGGER
Due to the widespread usage of the internet, consumers frequently download a ton of
freeware that could damage their systems. Although many pieces of software make claims
about their safety and lack of risks, they may really contain viruses or keyloggers that their
systems are vulnerable to. Once viruses are present, they tend to spread throughout the
system and eventually infect the device by corrupting the folders and directories. This may
prevent access to crucial data, such as the OS kernel and bootstrap loaders, and may even
cause these data to be erased, which would prevent the system from even starting or
launching applications. Keyloggers, however, differ from viruses and worms in that they
don't reproduce or spread throughout the system. They are primarily made to log or record
the victim's keystrokes. The most common ways that keyloggers gain access to a system
are through emails, careless downloads, and depending on how vulnerable the machine is,
like Windows computers. These can be employed in businesses where a manager wants to
monitor staff activity to prevent the alteration of sensitive data and the outsourcing of
private information.
2.1.1 TYPES OF KEYLOGGERS
The two main categories of keyloggers are hardware keyloggers and software keyloggers.
Hardware components allow hardware keyloggers to enter the system. A "ghost" element

that is physically attached to the object of focus is a typical example of a keylogger of this
type. By doing so, data can be taken and saved within the same device.
Another illustration is the "Spy" keylogger, which serves as a middleman between the
keyboard's USB adapter and the motherboard's USB port. The "Man in the Middle" attack
is a notorious term for this type of implementation.
The third type, known as "wireless hardware keyloggers," may translate and store
encrypted keystroke bits sent from input devices to the computer, including wireless
keyboards.
This project is mostly concerned with keylogger software. The rationale is that they are the
most widely used type of keystroke logging, are designed primarily for consumer use, are
inexpensive, and are easily accessible online.
Software keyloggers might be based on JavaScript, hypervisor, kernel, API, form grabbing,
or memory injection.
API based
A user application's keyboard APIs are where this type of keylogger latches on. In the
guise of a conventional user program, the keylogger records keystroke events.
Hypervisor based
A hypervisor is a piece of software or firmware that controls user applications and
hardware. Additionally, several apps can share a single hardware resource. Keyloggers can
use malware hypervisors that run beneath the OS to remain undetected by doing this. "Blue
pill" is a good illustration of this.
Kernel Based
In this type of keylogging, the program gains root access without the user's knowledge in
order to blend in with the operating system. These programs then act as an interceptor,
logging keystrokes as they pass through the kernel into a remote file that can be located on
the system and sent to the attacker.
Form Grabbing based
These keyloggers can collect users' private information when they submit online forms,
and they can then be used to activate other malicious activities.
JavaScript Based
Malicious web script tags are introduced into the target websites by this kind of keylogger.
The keylogger can listen for keystrokes using these tags.
Memory Injection based

These types carry out their keystroke tracking operations by making changes to memory
tables connected to system operations and web browsers. Modifications can involve
injecting itself into the system's memory or altering memory tables.
2.1.2 THE THREATS PRESENT
Webcam and microphone recordings include both audio and video. It could include any
personal information or secret information. Literally anything that we have typed on the
keyboard is included. This includes the barcodes on our items and credit card information,
as well as our passwords.
It records the websites you've visited, the files you've browsed, and any folders, files, or
data you may have access to. Additionally, it keeps track of all of your private
conversations, emails, and message exchanges. It can be saved as text files, screenshots,
and audio-visual pictures.
These keylogger concerns can be exploited by utilizing personal information for
marketing, particularly health records known as PHI, which can be highly expensive for
many healthcare organizations. The corporation could suffer a large financial loss as a
result of a product trademark leak.
Attackers can cause masked or modified data attacks on victims by using information to
evaluate traffic flow. It could be applied to send a person to unauthorized websites.
2.1.3 WAYS TO INFECT
Keyloggers can infect a computer in a number of different ways. A threat to the system
could result from opening attachments or accessing links from unknown sources.
random software downloads from malicious websites For instance, if a user accidentally
installs software or a package from the internet that contains the keylogger application, the
computer may get infected, allowing the keystrokes to be recorded and utilized unethically.
System vulnerability can result from outdated and bug-filled software.
Keylogger operations are comparable to social engineering, in which computer systems
can be compromised by taking advantage of psychological weaknesses in people.
2.2 EXISTING SYSTEM
Using a "Secure Desktop" is one of the methods frequently used to stop keyloggers from
remaining on your machine. Keyloggers and other remote administration applications
cannot access users' private information when using the Secure Desktop software, which
allows apps to be accessed in a secure location. In order to use secure desktop, you must
first establish a new virtual desktop and then launch the desired applications on it.
Keystrokes that can be traced on a regular desktop cannot be tracked on a secure desktop
because Windows Secure Desktop prevents dangerous apps from abusing the secure
desktop.
Disadvantages

Although keyloggers can't record keys by using secure desktops
The system tries to recognize pressing or mouse motions, but fails. One of the principal
Secure Desktop's drawbacks include not only resource-wasting practices but also
slows the system down.
2.3 PROPOSED SYSTEM
The keylogger detector proposed in this research is intended to specifically address the
problem of keystroke logging. Additionally, it uses few resources, is lightweight, and is
user-friendly because it can be easily run as an executable.
This software contains a signature base that is essential for distinguishing a keylogger from
other software. This is accomplished by compiling a database of keylogger signatures.
These signatures are the result of in-depth analysis of historical malware archives and
ongoing research on the signature patterns of active keyloggers. Using the clamAV tool is
another method of generating signatures. This open source toolkit provides a command
named sigtool that may be used to collect the signatures of programs that can pose dangers.
Based on the most recent keylogger trends, the signature database can be updated on a
regular basis.
2.4 SOFTWARE DESCRIPTION
2.4.1 JAVA
Concurrent, class-based, object-oriented, and deliberately created to have as few
implementation dependencies as possible, Java is a general-purpose language. It is meant
to provide "an option to form once, run wherever" (WORA) to application developers,
implying that orchestrated Java code can continue to execute on all phases that support
Java without the necessary need for recompilation. Java applications are frequently
compiled into bytecode that may run on any Java virtual machine (JVM) regardless of the
design of the computer. With an estimated 9 million specialists as of 2016, Java is one of
the most widely used programming languages, notably for client-server online
applications.
James Gosling created Java at Sun Microsystems, which was later acquired by Oracle
Corporation. It was first released in 1995 as an internal component of Sun Microsystems'
Java arrange. The tongue borrows a significant portion of its accent from C and C++, but it
has fewer low-level jobs than those two.
The development of the Java language went in five basic directions:
It ought to be "important, question-organized, and prominent."
It must be "secure and intense."
It must be "building impartial and smaller," "execute with predominant," "hung and
dynamic," and "deciphered."
One of Java's design goals is portability, which means that projects created for the Java
organize must function similarly on any combination of hardware and operating systems
with sufficient runtime support. Instead of using precisely defined specialized machine
code, this is accomplished by compiling the Java language code into a universally
attractive representation known as Java bytecode. Even though Java bytecode bearings are
the same as machine code, they are nevertheless intended to be run by a virtual machine

(VM) created specifically for the host hardware. For standalone Java applications or in a
web browser, end users often use a Java Runtime Environment (JRE) displayed without
any additional unique computer a Java applet software. Standard libraries provide a simple
method for gaining access to specialized capabilities, such as representations, threading,
and sorting.
Direct porting is made possible by the use of complete bytes. Nevertheless, deciphered
operations frequently ran slower than neighboring executables due to the overhead
involved in translating bytecode into machine rules. Compilers that ask for bytecodes to be
converted to machine code in the middle of runtime (JIT) were visible from the beginning.
A Java virtual machine for it translates the Java bytecode into the machine lingo of the
stage in order to make Java itself arrange free and modify according to the specific stage it
is to continue running on.
2.4.2 JAVA FX
JavaFX is a product stage for making and conveying work area applications, and in
addition it is responsible for making Internet rich applications (RIAs) that are capable of
running over a wide range of gadgets. JavaFX is proposed to supplant a Swing as the
standard GUI library for Java SE, however both will be incorporated for a long time to
come. JavaFX has bolster for PCs and web programs on Windows systems, systems using
Linux and Mac operating systems.
The earlier form 2.0 of JavaFX, designers utilized a statically composed, decisive dialect
called JavaFX Script to fabricate JavaFX applications. Since JavaFX Script was
incorporated to Java bytecode, developers could likewise utilize Java code. JavaFX
applications could keep running on any work area that could run Java SE or on any cell
phone that could run Java ME.
Applications using JavaFX are created in "local" Java code as of JavaFX 2.0 and later
versions are implemented as "local" Java libraries. Although Oracle rejected JavaFX
Script, the Visage project is still moving forward. [4] The Solaris operating system and
mobile devices are not supported by JavaFX 2.x, however Oracle plans to align JavaFX
with Java SE Embedded 8, and JavaFX for ARM processors is now at the engineer review
stage.
2.4.3 JNATIVEHOOK API
JNativeHook is a package for Java that provides general comfort and recorded input data.
This will allow you to pay attention to general business practices or mouse progress that
would otherwise be impossible using pure Java. JNativeHook uses the Java adjacent
interface to orchestrate low-level structure wide obtains and send those occasions to your
application in order to complete this task.
The methods for their specific group members make it possible for them to access the
running with events.
● Key Press Events
● Key Release Events
● Key Typed Events

● Mouse Down Events
● Mouse Up Events
● Mouse Click Events
● Mouse Move Events
● Mouse Drag Events
● Mouse Wheel Events
2.4.4 CLAM AV
ClamAV is a free, cross-platform, open-source toolbox equipped to detect many types of
harmful code. The program was designed for Unix, but there are furthermore available
versions for AIX, BSD, HP-UX, Linux, macOS, OpenVMS, OSF (Tru64), and Solaris.
ClamAV manufactured and continues to run on Microsoft Windows as of version 0.97.5.
Starting on February 10, 2017, the ClamAV infection database had more than 5,760,000
infection marks, with the daily refresh Virus DB number at 23040. The ClamAV infection
database is updated at least once every week.
Framework managers primarily use ClamAV Unofficial Signatures to route email
messages. Instead of creating an inside and outside square with the "infected" message, the
location of these gatherings should be scored. The sigtool feature of ClamAV is used in
order to capture the signatures of the well-known malicious keyloggers.
Sigtool
A mark database (cvd) control system for mark researchers and malware analysts.
A free, open-source, cross-platform antivirus toolset called Shellfish Antivirus (ClamAV)
is equipped to detect several forms of malicious software, including infestations. One of its
main applications is as a server-side infection scanner on mail systems. On August 17,
2007, Sourcefire, a manufacturer of interruption recognition tools and the owner of Snort,
announced that it had acquired the trademarks and copyrights of ClamAV from five
important engineers. The ClamAV group joined the Sourcefire VRT after signing up for
Sourcefire.
Cisco bought Sourcefire as a result in 2013. Cisco Talos evolved from the Sourcefire
Vulnerability Research Team (VRT), and ClamAV development continues there. ClamAV
includes a number of tools, including a command line scanner, a programmed database
updater, and a flexible multi-strung daemon that uses an anti-infection motor from a shared
library.
The ClamAV infection database is updated at least once every week, and as of February
10th, 2017, it contains more than 5,760,000 infection marks with a daily refresh Virus DB
number of 23040.
2.4.5 APACHE COMMONS CODEC
Usage of common encoders and decoders, such as Base64, Hex, Phonetic, and URLs, is
made possible by the Apache Commons Codec (TM) programming.
Following are the several packages included in the Apache Commons Codec:

1.org.apache.commons.codec
It contains interfaces and classes that are utilized by various implementations in a sub
package.
2.org.apache.commons.codec.binary
Base32, Base64, Hexadecimal, and Binary String encoding and decoding are all supported.
3. org.apache.commons.codec.digest
contains encryption techniques that work with the MD5, DES, SHA-512, and SHA-256
algorithms.
4. org.apache.commons.codec.language
includes linguistic and phonetic encoders.
5. org.apache.commons.codec.language.bm
includes information about the Beider-Morse (BM) codec's implementation.
6. org.apache.commons.codec.net
aids in network-related encoding and decoding.
In an effort to focus development efforts on a single reliable Base64 encoder execution,
Codec was created. At the time of Codec's proposal, the Foundation's CVS store contained
approximately 34 different Java classes that handled Base64 encoding. The Base64 codec
was modified specifically by the Jakarta Tomcat project's engineers, and it was then copied
by the Commons Http Client and the XML-RPC subproject of the Apache XML task. The

two forked versions of Base64 have virtually split apart after very nearly a year. The XML-
RPC

a number of fixes, as well as fixes not tied to the Commons HTTP Client
Base64. Varying subprojects had different executions at various levels of
conformity with RFC 2045. That perplexing repetition of effort gave rise to
this fundamental effort to encourage code reuse across several projects. Although this
package
includes a conceptual framework for the development of encoders and decoders.
largely focussed on providing practical tools for using simple encodings.
CHAPTER 3
REQUIREMENT ANALYSIS
3.1 FUNCTIONAL REQUIREMENTS
A functional requirement in programming designing defines a component of a product
framework or its segment. A capacity is defined as a combination of information sources,
behaviors, and outputs. Figures, specialized subtle elements, information control and
handling, and other specific utility that define what a framework should accomplish are
helpful requirements. Every instance in which the framework makes use of the helpful
prerequisites is depicted by the social requirements.

An element of a framework for its part is characterized by a practical necessity in software
development and framework design. A capacity is represented as a combination of
informational sources, behaviors, and outputs.
Estimates, technical details, information control and processing, and other specific
usefulness that identify what a framework should accomplish are useful precondition.
Every instance in which the framework makes use of the utilitarian requirements is shown
by the social requirements. Non-practical requirements, often known as quality
requirements, support utilitarian requirements by imposing requirements on the design or
use, such as performance requirements, security requirements, or unwavering quality.
Practical requirements are typically expressed in the form "framework must do
requirement>," whereas non-utilitarian requirements are expressed in the form "framework
should be requirement>." The framework outline details the arrangement for carrying out

utilitarian demands. The framework engineering has a detailed plan for carrying out non-
practical prerequisites.

3.2 NON-FUNCTIONAL REQUIREMENTS
A non-practical prerequisite is a necessity that establishes criteria that can be used to
appraise the task of a framework, rather than specific practices, in the planning and
constructing of frameworks. This should be distinguished from practical requirements that
define particular behaviors or abilities.The framework overview lists the organization for
implementing useful necessities.
The framework design specifies how non-practical prerequisites will be carried out point
by point.
Non-utilitarian needs are also referred to as "non-social necessities," "quality features,"
"quality objectives," "imperatives," and "nature of administration prerequisites."
In general, practical requirements define what a framework should be able to perform,
whereas non-utilitarian requirements define how a framework should be. An specific
activity or component of the framework, sometimes explicitly in the sense of a scientific
ability, a discovery depiction input, yield, process, and control practical model, or IPO
Model, are typically useful conditions that "framework should perform."It's interesting to
note that non-practical requirements are expressed as "framework might be required>,"
which is a generic characteristic of the framework in general or of a particular perspective
rather than a specific capability.
"Quality attributes" of a framework are frequently used to describe non-utilitarian
requirements. Other terms for non-useful requirements include "characteristics," "quality
objectives," "necessities of nature of administration," "imperatives," and "non-social
requirements." These are occasionally known as the "ilities" informally due to qualities
like solidity and mobility. Characteristics, or non-necessities, can be divided into two main
categories:
execution qualities that are evident during a task, such as health, security, and usability (at
run time). The framework's static structure contains development features including
testability, practicability, extensibility, and adaptability. The following list includes several
qualities:
3.2.1 ACCESSIBILITY

The word "accessibility" is a broad term used to describe how many people are able to use
a certain product, device, service, or condition. In our project, people who have signed up
for the cloud can access the cloud to save and retrieve their information with the use of a
secret key issued to their email addresses. The openness of a PC platform makes its user
interface simple, effective, and easy to use for everyone, regardless of disability or degree
of weakness.
3.2.2 MAINTAINABILITY
Practicality in programming design refers to how easily a product element can be modified
with the intention of:
Change deserts and accommodate new requirements
By simply adding the appropriate documents to an existing project, new functionality
depending on customer requirements can be added using the ASP.net and C# programming
languages. Due to how simple it is to write computer programs, flaws can be found and
fixed more easily, and project enhancements can be implemented more easily.
In construction, practicality refers to the ease with which a product can be maintained in
order to: address problems or their causes, repair or replace worn-out or broken parts
without replacing still-functioning ones, prevent sudden working conditions, increase an
item's useful life, improve proficiency, dependability, and wellbeing, satisfy new
requirements, make future support less difficult, or adapt to a changed situation.
3.2.3 SCALABILITY
When assets (often equipment) are added, the framework is capable of handling increment
add up to throughput under an increased demand. Framework can function normally in
situations like poor data transport capacity and a large number of customers. The ability of
a framework, system, or method to handle a growing volume of work, or the capacity to be
expanded to accommodate that growth, is referred to as versatility.
For instance, a system is considered flexible if it is capable of increasing its overall yield
under a greater load when assets (often equipment) are added.
The framework can handle an increase in throughput under a higher demand when assets
(typically equipment) are added. When there are many consumers and a low data transit
capacity, the framework can still operate normally. Versatility is the capacity to grow in
order to handle an increase in workload or the ability of a framework, system, or approach
to do so.
For instance, if a system can increase its overall yield while operating under a heavier load
when assets (typically equipment) are added, it is said to be flexible.circumstances (such as
a large informational index, a large number of clients, or a large number of gathering hubs
as a result of a distributed system).
3.2.4 PORTABILITY
One of the fundamental principles of abnormal state programming is portability. The
ability to reuse existing code rather than creating new code when transferring
programming from one context to another is known as portability. If the venture meets its

fundamental requirements, it can be carried out in a variety of task conditions. In such a
scenario, only the framework records and dependent groups would need to be built.
Various programming options include: transferring newly introduced program records to a
another computer with a fundamentally comparable design. installing a program again
from distribution records on a different computer with essentially the same engineering.
"Porting" is typically understood to mean creating executable projects from source code
for various phases.
3.3 HARDWARE REQUIREMENTS
Processor Any processor above 500 MHz
RAM2GB
Hard Disk10GB
Input Device Standard Keyboard and Mouse
Output Device High Resolution Monitor
3.4 SOFTWARE REQUIREMENTS
Operating System Windows 7 or more, All flavors of Linux
Front End JavaFX 9.0
IDEE clipse Oxygen 4.7.3a
Server Apache Commons
CHAPTER 4

DESIGN

4.1 DESIGN GOALS
An easy-to-use, lightweight program that can identify keyloggers on computers is
provided. It also guides the user to remove any dangerous files or contents that may be
present on the computer.
4.1.1 PRIVACY
By preventing the user's login details and sensitive data from being taken from the system,
it protects the privacy of user data. This is accomplished by identifying any keyloggers that
may be present on the system.
4.1.2 ACCURACY
With the aid of the signature database it is connected to, the detector can identify
keyloggers that have been installed on the system. Over 70,000 signatures in the signature
database can be used to identify the keylogger, even if it tries to blend in.
4.2 SYSTEM ARCHITECTURE

4.2.1 KEYLOGGER
The keystrokes are recorded by the keyloggers we developed, which also record all mouse
movements, including dragged, scrolled, and pressed movements. These movements of
these input devices are then logged into the attacker's system or stored locally in a notepad
and sent to our email addresses every few days or weeks.
The JNativeHookAPI, which hooks itself on to the APIs of input devices like the keyboard
and mouse, is used by the keylogger we developed.
It then abruptly executes a regular bit of code, poses as a secure application, and
successfully navigates all implemented security measures.
These keyloggers have the ability to stalk users and covertly follow their whereabouts and
activities. Client and server pieces each make up two of it. The server file, which runs on
the victim side and logs keystrokes, comes in the form of a jar file.
The client is later sent a text file containing the recorded keystrokes. This file transfer is
carried out on a regular basis to make sure we have received all of the user's data. The
Keylogger's client is the device that receives the information transmitted by the server
application running on the victim's end. Then, this client application gives us the crucial
information about the user who is under our watchful eye.
4.2.2 SIGNATURE FILE
The collection of signatures is known as the signature database. Every every file, folder,
and application that is created contains a distinct signature. Using a program called
ClamAV, these signatures can be extracted from the files, directories, or any application.
We conducted investigation, found numerous keyloggers, and extracted the keyloggers'
signatures. Nearly 75,000 signatures, which are those of keyloggers discovered on web
servers, other systems, infected devices, etc., are stored in the signature database. It
contains the signatures of the worst and most heinous keyloggers. It also contains the
signatures of the keyloggers we created.
This signature database is a text file, not a table or any other kind of structure. To make
sure that it has been updated with genuine and all available keyloggers, this signature
database can be updated often or over the course of a few months. By keeping it updated,
we may continue to use it for a very long time without having to produce new software
updates for the already developed keylogger detector.
When matching files, this signature database is called in order to look for keyloggers.
4.2.3 DETECTOR
The detector, which upholds the important role and personifies keylogger detection, is the
project's principal engine. The basic foundation of the detector is the keylogger's built-in
signature detection algorithm. It asks the user to provide the path to a folder or file that he
suspects may contain a keylogger.
The program will be terminated if the user does not accept the agreement or license on the
detector's included page before continuing with the detection. The terms and conditions
only serve to control how the software is used and guard against tampering or abuse. While

looking for keyloggers in the system, it is also morally correct to obtain the user's consent
before accessing sensitive data.
The scanning process is quite quick, therefore the user doesn't need to waste time. The user
is subsequently led to a subsequent step, where the files and folders scanned are
displayed.There are two divisions in the display. One section includes a list of all the
scanned files and folders that were processed during scanning. The matching file contents,
which are actually keyloggers, are projected in the second part. It doesn't truly remove the
keylogger; instead, it shows where it is. It is expected of the user to follow the instructions
and eliminate the keylogger, which could be harmful to the user.
After passing each step, the user advances by clicking continue, which takes him to two
scenes. If a keylogger is not identified, the first scene shows vulnerability, while the
second scene shows "protected."The user is then given the option of shutting the
application for a future user or scanning again, which starts him at the beginning of each
stage. It takes time to thoroughly check the chosen folder or file path when huge files are
provided. The output will display faster if the folder is less in size. It is advisable to run
this detector right away after downloading any software, files, or folders that can pose a
threat to the system. When a device is brought to the system that could pose a threat, it
might be used.
4.3 DATA FLOW DIAGRAM

4.4 SEQUENCE DIAGRAM

4.5 USE CASE DIAGRAM

CHAPTER FIVE.

IMPLEMENTATION

5.1

KEYLOGGER USING JNATIVEHOOK
I conducted investigation, found numerous keyloggers, and extracted the keyloggers'
signatures. Nearly 75,000 signatures, which are the signatures of keyloggers discovered on
online or other systems or other infected devices servers etc., are stored in the signature
database. It contains the signatures of the worst and most heinous keyloggers. It also
contains the signatures of the keyloggers we created. This signature database is a text file,
not a table or any other kind of structure. To make sure that it has been updated with
genuine and all available keyloggers, this signature database can be updated often or over
the course of a few months.By keeping it updated, we may continue to use it for a very
long time without having to produce new software updates for the already developed
keylogger detector.
When matching files, this signature database is called in order to look for keyloggers.
5.2 SCANNING FILE STRUCTURES

The scanning process is quite quick, therefore the user doesn't need to waste time. The user
is subsequently led to a subsequent step, where the files and folders scanned are displayed.
One section of the display, which is divided into two halves, contains a list of all scanned
files and folders that have through the scanning process.
The matching file contents, which are actually keyloggers, are projected in the second part.
It doesn't truly remove the keylogger; instead, it shows where it is. It is expected of the
user to follow the instructions and eliminate the keylogger, which could be harmful to the

user. After passing each step, the user advances by clicking continue, which takes him to
two scenes.The first scene which displays, vulnerability and the
second scene displays "protected" if no keylogger is not found.
The user is then given the option of shutting the application for a future user or scanning
again, which starts him at the beginning of each stage. It takes time to thoroughly check
the chosen folder or file path when huge files are provided.
The output will display faster if the folder is less in size. It is advisable to run this detector
right away after downloading any software, files, or folders that can pose a threat to the
system. When a device is brought to the system that could pose a threat, it might be used.
5.3 SIGNATURE MATCH
The collection of signatures is known as the signature database. Every every file, folder,
and application that is created contains a distinct signature. Using a program called
ClamAV, these signatures can be extracted from the files, directories, or any application.
We conducted investigation, found numerous keyloggers, and extracted the keyloggers'
signatures.
Nearly 75,000 signatures, which are those of keyloggers discovered on web servers, other
systems, infected devices, etc., are stored in the signature database. It contains the
signatures of the worst and most heinous keyloggers. It also contains the signatures of the
keyloggers we created.
The format of this signature database is a text file (.txt), not a table or any other kind of
format. To make sure that it has been updated with genuine and all available keyloggers,
this signature database can be updated often or over the course of a few months. By
keeping it updated, we may continue to use it for a very long time without having to
produce new software updates for the already developed keylogger detector.
When matching files, this signature database is called in order to look for keyloggers.

5.4 FUNCTIONS USED
Some of the Major Functions Used are:
logScanToFile - When a folder or a file is provided to the detector, the file path that was
scanned is recorded.
LogMatchToFile- Records the locations of the files containing keylogger vulnerabilities
and their paths.
ListReadLines- Reads the file from signature database.
Detect-uses many other functions in addition to the compare action , to find the
keyloggers
match.exists - displays whether the vulnerable file is present in the system or prints "no
threats found".
start - found inside the main ,which launches the detector for scanning.
ScanAction - Does the actual scanning of folders
Browse Action - Allows user to select a folder
FinishAction - Direct the user to vulnerable page or protected page is taken care by this
function.
RadAction- Allows user to toggle between matched file display and scanned file

display.
ProgressAction - Displays the scan complete page once scanning is done
NextAction - Allows the user to surf to next page.
RadioAccept - Allows the user to accept the terms and conditions agreement.
CancelAction - Allows user to quit from application.
Scan again - Does the scanning process again for the detection of keylogger.

CHAPTER 6

TESTING
Testing is done to look for mistakes. Testing is the process of looking for any flaws or
weaknesses in a piece of work. It is the process of exercising software with the aim of
ensuring that the Software system satisfies its requirements and user expectations and does
not fail in an unacceptable fashion. It provides a mechanism to test the functionality of
components, sub assemblies, assemblies, and/or a finished product. There are several
different test types. Every test type responds to a certain testing requirement.
6.1 UNIT TESTING
Designing test cases for unit testing ensures that the internal program logic is working
correctly and that program inputs result in legitimate outputs. It is important to verify the
internal code flow and all decision branches. It is the testing of the application's separate
software components. Unit tests make assurance that each distinct path of a business
process adheres precisely to the stated specifications and has inputs and outputs that are
well-defined.
A unit in object-oriented programming is frequently a full interface, like a class, although it
also could be a single method. During the development process, programmers and
occasionally white box testers write little pieces of code known as unit tests. The
foundation of component testing is it.
For this portion of the threat detection testcases, we have chosen the keyloggers that we
have created for our projects. It has been examined for a variety of keyloggers that are
openly accessible online or that we have found on other personal devices. It has shown to
be 100% successful at finding all of those keyloggers. These keyloggers' signatures are
saved in a database of signatures. Our unit test cases include signatures from the signature
database as well.
The unit test test cases are created as follows. The detector is checked for a regular
execution in the first test case, where no keyloggers are present. It was successful and did
not provide any false-positive results.

Then we included keyloggers as the second test case, although this test case is actually a

test suite with numerous keyloggers that were spread throughout our system in hard-to-
reach locations. One of the keyloggers that we eliminated was in the recycle bin, and it was

also correctly discovered. The test case was a complete success, demonstrating spoof proof
detection. The keylogger detector was demonstrated to be stable, dependable, and
trustworthy software despite numerous failures.
6.2 INTEGRATION TESTING
Unit testing is completed first, followed by integration testing, which is completed before
validation testing. Unit testing modules serve as the inputs for integration. Integration
testing is the process of integrating these modules to create a larger system and testing it
again.
The test case is applied here based on the test case suite after the system has been
integrated.
Applying test cases can be done in a variety of ways, such as the top-down technique,
bottom-up approach, big bang strategy, sandwich method, etc. In the big-bang approach,
the developed programs are integrated to produce a whole new software with the inclusion
of features from the sub features.
The tester can determine whether the vulnerabilities that were concealed during unit testing
have now come to light thanks to integration testing, which may expose flaws that were
missed during unit testing. In a bottom-up method, the line-level modules are integrated
first, followed by the higher-level modules, to create the desired program. In top-down
testing, the top-level modules are integrated first, followed by the integration of the
modules at the lower levels.
This makes it easier to comprehend the software in terms of minor integrations, and new
functionality can be introduced if they are discovered throughout the integration testing
process.
The fact that any unspecified integration testing settings typically result in a successful test
with no flaws is a drawback of this type of testing methodology. Another drawback of this
kind of testing is that it takes more time because we test by merging software components
one at a time.
6.3 VALIDATION TESTING
Making the proper product necessitates writing a requirements specification that details the
objectives of the software product's stakeholders. Developers won't be able to create the
product that stakeholders are looking for if such an artifact is inaccurate or incomplete.
"Artifact or specification validation" is what this is.
Software validation can be done in one of two ways: internally or externally. It is presumed
during internal software validation that the stakeholders' objectives were clearly
understood and accurately and fully articulated in the requirement artifacts. The program
has been internally validated if it complies with the required definition. Asking the
stakeholders whether the software satisfies their needs constitutes external validation.
External validation can be a discrete or ongoing process since different software
development methodologies ask for different amounts of user and stakeholder involvement

and feedback. When all parties involved accept the software product and state that it
satisfies their needs, final external validation is successful. An acceptance test, a dynamic
test, is required for this last external validation.
First, the server application was constructed for the project and tested using unit testing to
see if it met the criteria. Similar client software was developed as part of the keylogger to
capture the victim's keystrokes. Unit testing was also used to test this.
The server and client were joined after passing integration testing, and integration testing
was then conducted on the entire software to produce the intended outcome. To verify the
operation of the keylogger and fix any faults that were discovered, we used the big bang
method of integration testing.
Then, using a bottom-up method, we combined the detector's many stages, including the
welcome screen, terms and conditions screen, user prompt screen, scan complete screen,
vulnerability screen, and protected screen. We unit tested each of the aforementioned
screens before combining them for integration testing. After integration, the detector
underwent a number of test cases that were outlined in the test suites. Test cases for the
detector's accuracy and precision comprised both vulnerable and non-vulnerable scenarios.
6.4 SYSTEM TESTING
Instead of testing the system as individual software components to find problems, the
entire system is tested in this sort of testing. Here, less time is needed because the entire
system is directly checked for flaws as opposed to doing so for each of its separate
subprograms. The process of creating test cases for system testing involves a number of
processes, including preparation, evaluation, revising, and baseline testing methodologies.
Acceptance testing comes before system testing. It is often carried out by knowledgeable
testers who are able to identify mistakes and correct them at the conclusion of the complete
software development process.
This testing, sometimes known as black box testing because it doesn't require design or
coding skills, uses integrated components that have passed integration testing as its input.
It examines if the entire system conforms with the listed functional requirements or may
also test for system compliance. Additionally, it aids the tester in doing tests that go
beyond all defined standards. The generated detector and keylogger were also subjected to
system testing using test cases created to gauge how well they performed. Both products
met the requirements and delivered the intended results.
System testing took less time because it was simple and quick to run the full test, but it
involved numerous test cases for false positives, protected systems, and vulnerability.

CHAPTER 7
CONCLUSION AND FUTURE ENHANCEMENT
7.1 CONCLUSION
The installed detection program aids in addressing the susceptible cyberspace where
keyloggers are frequently used to launch large-scale attacks. Additionally, the built-in test
keyloggers offer a look inside a malware's inner workings. The detection aids in upholding
a vulnerable user's general security. It is effective in finding threats within the
neighborhood system.
7.2 FUTURE ENHANCEMENT
The project is now performed manually on the local PC, but it might be improved to
become a browser plugin that does checks automatically each time a file is downloaded.
This would assist in addressing the security issues now present in mail and browser
systems. Additionally, machine learning features that could extract the signature from
possible assaults could be implemented in the Signature database.

REFERENCES
[1] Spybot – Search & Destroy 1.4, http://www.spybot.info/en/
[2] Remacc.SpyAnywhere - Symantec.com,
http://www.symantec.com/security_response/writeup.jsp?docid=2004 -091717-4118-
99
[3] Spyware.Perfect - Symantec.com,
http://www.symantec.com/security_response/writeup.jsp?docid=2003 -100210-1458-
99
[4] Spyware.ActivityLog - Symantec.com,
http://www.symantec.com/security_response/writeup.jsp?docid=2004 -062311-5929-
99

[5] Spyware.XpcSpy - Symantec.com,
http://www.symantec.com/security_response/writeup.jsp?docid=2004 -062813-4844-
99
[6] key.exe - Vector, http://rd.vector.co.jp/soft/win95/util/se322072.html
[7] KeyLogger, http://www.urban.ne.jp/home/noda/
[8] Parasite - Vector, http://www.vector.co.jp/soft/winnt/util/se327656.html
[9] WingKEY - Vector, http://www.vector.co.jp/soft/winnt/util/se263226.html
[10] keylog.exe - Vector, http://www.vector.co.jp/soft/win95/util/se369025.html
[11] Keylogger Hunter, http://www.styopkin.com/keylogger_hunter.html
[12] Keylogger Stopper, http://www.chithai.com/keystop.htm
[13] Anti-Keylogger Elite, http://www.remove-keyloggers.com/index.php

[14] Microsoft – Windows API (Windows), http://msdn2.microsoft.com/en-
us/library/aa383750.aspx
